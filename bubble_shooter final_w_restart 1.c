
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <math.h>


#define LCD_BUFF        ((unsigned short *)0xc8000000)
#define KEY_NUM            (*((volatile int *)0xff200050))
#define KEY_value        (*((volatile char *)0xFF200050))
#define ABS(X)          ((X) > 0 ? (X) : -(X))
    
void sleep(int seconds) {
    clock_t start_time = clock();
    while (clock() < start_time + seconds * CLOCKS_PER_SEC);
}

//Beep function
void beep() {
    unsigned int fifospace;
    volatile int * audio_ptr = (int *) 0xFF203040; //Base address for audio port

    int duration = 500;
    
    for (int i = 0; i < duration; i++) {
        fifospace = *(audio_ptr+1); //Read the FIFOSPACE register (holds read AND write data)
        if ((fifospace & 0x000000FF) > 0 &&    //Make sure the read space is free.
            (fifospace & 0x00FF0000) > 0 &&    //Make sure R write space is free
            (fifospace & 0xFF000000) > 0) //Make sure L write space is free
        {
            int sample = *(audio_ptr + 3);    //Get sample data from R CH (MIC)
            *(audio_ptr + 2) = sample; //Write to L and R CH
            *(audio_ptr + 3) = sample;
        }
    }
}

//Explosion sound - Non-functional
void explosion_sound() {
    int num_beeps = 10;
    int delay = 1000;

    for (int j = 0; j < num_beeps; j++) {
        for (int i = 0; i < delay; i++) {}
        beep();
    }

}

void draw_point(int x,int y,short int color)
{
    if(x<0||y<0||x>=320||y>=240) return;
    LCD_BUFF[y*512+x]=color;
}

    

void wait_for_vsync() {
    volatile int* pixel_ctrl_ptr = 0xff203020;
    register int status;
    
    *pixel_ctrl_ptr = 1;
    
    status = *(pixel_ctrl_ptr +3);
    while ((status & 0x01) != 0) {
        status = *(pixel_ctrl_ptr +3);
    }
}

void clear_screen() {
    for ( int i = 0; i < 320; i++) {
        for ( int j = 0; j < 240; j++) {
            draw_point(i, j, 0);
        }
    }
}

 
void draw_line(int x1, int y1, int x2, int y2,int color)
{
    int t;
    int xerr=0,yerr=0,delta_x,delta_y,distance;
    int incx,incy,uRow,uCol;
    delta_x=x2-x1;
    delta_y=y2-y1;
    uRow=x1;
    uCol=y1;
    if(delta_x>0)incx=1;
    else if(delta_x==0)incx=0;
    else {incx=-1;delta_x=-delta_x;}
    if(delta_y>0)incy=1;
    else if(delta_y==0)incy=0;
    else{incy=-1;delta_y=-delta_y;}
    if( delta_x>delta_y)distance=delta_x;
    else distance=delta_y;
    for(t=0;t<=distance+1;t++ )
    {
        draw_point(uRow,uCol,color);
        xerr+=delta_x ;
        yerr+=delta_y ;
        if(xerr>distance)
        {
            xerr-=distance;
            uRow+=incx;
        }
        if(yerr>distance)
        {
            yerr-=distance;
            uCol+=incy;
        }
    }
}


void draw_fill (int x,int y,int x_size,int y_size,int color)
{
    for(int i=0;i<y_size;i++){
        for(int j=0;j<x_size;j++){
            draw_point(j+x,i+y,color);
        }
    }
}



void draw_rect(int x,int y,int x_size,int y_size,int color)
{
    draw_line(x,y,x+x_size,y,color);
    draw_line(x,y,x,y+y_size,color);
    draw_line(x+x_size,y,x+x_size,y+y_size,color);
    draw_line(x,y+y_size,x+x_size,y+y_size,color);
}



void draw_circle(int x0,int y0,int r,int color)
{
    int a,b;
    int di;
    int c_x=0;
    a=0;b=r;
    di=3-(r<<1);
    while(a<=b)
    {
        c_x=x0+a;
        draw_line(c_x,y0-b,c_x,y0+b,color);
        c_x=x0+b;
        draw_line(c_x,y0-a,c_x,y0+a,color);
        c_x=x0-a;
        draw_line(c_x,y0-b,c_x,y0+b,color);
        c_x=x0-b;
        draw_line(c_x,y0-a,c_x,y0+a,color);
        a++;
        if(di<0)di +=4*a+6;
        else
        {
            di+=10+4*(a-b);
            b--;
        }
    }
}






void draw_fill_triangle(int x1, int x2, int x3, int y1, int y2, int y3,int color)
{
  int deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0,
  yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0,
  curpixel = 0;

  deltax = ABS(x2 - x1);        /* The difference between the x's */
  deltay = ABS(y2 - y1);        /* The difference between the y's */
  x = x1;                       /* Start x off at the first pixel */
  y = y1;                       /* Start y off at the first pixel */

  if (x2 >= x1)                 /* The x-values are increasing */
  {
    xinc1 = 1;
    xinc2 = 1;
  }
  else                          /* The x-values are decreasing */
  {
    xinc1 = -1;
    xinc2 = -1;
  }

  if (y2 >= y1)                 /* The y-values are increasing */
  {
    yinc1 = 1;
    yinc2 = 1;
  }
  else                          /* The y-values are decreasing */
  {
    yinc1 = -1;
    yinc2 = -1;
  }

  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
  {
    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
    yinc2 = 0;                  /* Don't change the y for every iteration */
    den = deltax;
    num = deltax / 2;
    numadd = deltay;
    numpixels = deltax;         /* There are more x-values than y-values */
  }
  else                          /* There is at least one y-value for every x-value */
  {
    xinc2 = 0;                  /* Don't change the x for every iteration */
    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
    den = deltay;
    num = deltay / 2;
    numadd = deltax;
    numpixels = deltay;         /* There are more y-values than x-values */
  }

  for (curpixel = 0; curpixel <= numpixels; curpixel++)
  {
    draw_line(x, y, x3, y3,color);

    num += numadd;              /* Increase the numerator by the top of the fraction */
    if (num >= den)             /* Check if numerator >= denominator */
    {
      num -= den;               /* Calculate the new numerator value */
      x += xinc1;               /* Change the x as appropriate */
      y += yinc1;               /* Change the y as appropriate */
    }
    x += xinc2;                 /* Change the x as appropriate */
    y += yinc2;                 /* Change the y as appropriate */
  }
}






static const unsigned char g_asc2_1608[95][16]={
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x18,0x18,0x00,0x00},/*"!",1*/
{0x00,0x12,0x36,0x24,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
{0x00,0x00,0x00,0x24,0x24,0x24,0xFE,0x48,0x48,0x48,0xFE,0x48,0x48,0x48,0x00,0x00},/*"#",3*/
{0x00,0x00,0x10,0x38,0x54,0x54,0x50,0x30,0x18,0x14,0x14,0x54,0x54,0x38,0x10,0x10},/*"$",4*/
{0x00,0x00,0x00,0x44,0xA4,0xA8,0xA8,0xA8,0x54,0x1A,0x2A,0x2A,0x2A,0x44,0x00,0x00},/*"%",5*/
{0x00,0x00,0x00,0x30,0x48,0x48,0x48,0x50,0x6E,0xA4,0x94,0x88,0x89,0x76,0x00,0x00},/*"&",6*/
{0x00,0x60,0x60,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00},/*"(",8*/
{0x00,0x40,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x40,0x00},/*")",9*/
{0x00,0x00,0x00,0x00,0x10,0x10,0xD6,0x38,0x38,0xD6,0x10,0x10,0x00,0x00,0x00,0x00},/*"*",10*/
{0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xFE,0x10,0x10,0x10,0x10,0x00,0x00,0x00},/*"+",11*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x20,0xC0},/*",",12*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"-",13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00},/*".",14*/
{0x00,0x00,0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x00},/*"/",15*/
{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00},/*"0",16*/
{0x00,0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00},/*"1",17*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x04,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00},/*"2",18*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x04,0x18,0x04,0x02,0x02,0x42,0x44,0x38,0x00,0x00},/*"3",19*/
{0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x44,0x7E,0x04,0x04,0x1E,0x00,0x00},/*"4",20*/
{0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x42,0x44,0x38,0x00,0x00},/*"5",21*/
{0x00,0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00},/*"6",22*/
{0x00,0x00,0x00,0x7E,0x44,0x44,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00},/*"7",23*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00},/*"8",24*/
{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x24,0x38,0x00,0x00},/*"9",25*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x20},/*";",27*/
{0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x02,0x00,0x00},/*"<",28*/
{0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00},/*"=",29*/
{0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x40,0x00,0x00},/*">",30*/
{0x00,0x00,0x00,0x3C,0x42,0x42,0x62,0x02,0x04,0x08,0x08,0x00,0x18,0x18,0x00,0x00},/*"?",31*/
{0x00,0x00,0x00,0x38,0x44,0x5A,0xAA,0xAA,0xAA,0xAA,0xB4,0x42,0x44,0x38,0x00,0x00},/*"@",32*/
{0x00,0x00,0x00,0x10,0x10,0x18,0x28,0x28,0x24,0x3C,0x44,0x42,0x42,0xE7,0x00,0x00},/*"A",33*/
{0x00,0x00,0x00,0xF8,0x44,0x44,0x44,0x78,0x44,0x42,0x42,0x42,0x44,0xF8,0x00,0x00},/*"B",34*/
{0x00,0x00,0x00,0x3E,0x42,0x42,0x80,0x80,0x80,0x80,0x80,0x42,0x44,0x38,0x00,0x00},/*"C",35*/
{0x00,0x00,0x00,0xF8,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0xF8,0x00,0x00},/*"D",36*/
{0x00,0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x42,0x42,0xFC,0x00,0x00},/*"E",37*/
{0x00,0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x40,0x40,0xE0,0x00,0x00},/*"F",38*/
{0x00,0x00,0x00,0x3C,0x44,0x44,0x80,0x80,0x80,0x8E,0x84,0x44,0x44,0x38,0x00,0x00},/*"G",39*/
{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/*"H",40*/
{0x00,0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00},/*"I",41*/
{0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x88,0xF0},/*"J",42*/
{0x00,0x00,0x00,0xEE,0x44,0x48,0x50,0x70,0x50,0x48,0x48,0x44,0x44,0xEE,0x00,0x00},/*"K",43*/
{0x00,0x00,0x00,0xE0,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x42,0xFE,0x00,0x00},/*"L",44*/
{0x00,0x00,0x00,0xEE,0x6C,0x6C,0x6C,0x6C,0x54,0x54,0x54,0x54,0x54,0xD6,0x00,0x00},/*"M",45*/
{0x00,0x00,0x00,0xC7,0x62,0x62,0x52,0x52,0x4A,0x4A,0x4A,0x46,0x46,0xE2,0x00,0x00},/*"N",46*/
{0x00,0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x44,0x38,0x00,0x00},/*"O",47*/
{0x00,0x00,0x00,0xFC,0x42,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0xE0,0x00,0x00},/*"P",48*/
{0x00,0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0xB2,0xCA,0x4C,0x38,0x06,0x00},/*"Q",49*/
{0x00,0x00,0x00,0xFC,0x42,0x42,0x42,0x7C,0x48,0x48,0x44,0x44,0x42,0xE3,0x00,0x00},/*"R",50*/
{0x00,0x00,0x00,0x3E,0x42,0x42,0x40,0x20,0x18,0x04,0x02,0x42,0x42,0x7C,0x00,0x00},/*"S",51*/
{0x00,0x00,0x00,0xFE,0x92,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00},/*"T",52*/
{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/*"U",53*/
{0x00,0x00,0x00,0xE7,0x42,0x42,0x44,0x24,0x24,0x28,0x28,0x18,0x10,0x10,0x00,0x00},/*"V",54*/
{0x00,0x00,0x00,0xD6,0x92,0x92,0x92,0x92,0xAA,0xAA,0x6C,0x44,0x44,0x44,0x00,0x00},/*"W",55*/
{0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00},/*"X",56*/
{0x00,0x00,0x00,0xEE,0x44,0x44,0x28,0x28,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00},/*"Y",57*/
{0x00,0x00,0x00,0x7E,0x84,0x04,0x08,0x08,0x10,0x20,0x20,0x42,0x42,0xFC,0x00,0x00},/*"Z",58*/
{0x00,0x1E,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1E,0x00},/*"[",59*/
{0x00,0x00,0x40,0x40,0x20,0x20,0x10,0x10,0x10,0x08,0x08,0x04,0x04,0x04,0x02,0x02},/*"\",60*/
{0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00},/*"]",61*/
{0x00,0x1C,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},/*"_",63*/
{0x00,0x60,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x1E,0x22,0x42,0x42,0x3F,0x00,0x00},/*"a",65*/
{0x00,0x00,0x00,0xC0,0x40,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x64,0x58,0x00,0x00},/*"b",66*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x22,0x40,0x40,0x40,0x22,0x1C,0x00,0x00},/*"c",67*/
{0x00,0x00,0x00,0x06,0x02,0x02,0x02,0x1E,0x22,0x42,0x42,0x42,0x26,0x1B,0x00,0x00},/*"d",68*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x7E,0x40,0x40,0x42,0x3C,0x00,0x00},/*"e",69*/
{0x00,0x00,0x00,0x0F,0x11,0x10,0x10,0x7E,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00},/*"f",70*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x44,0x44,0x38,0x40,0x3C,0x42,0x42,0x3C},/*"g",71*/
{0x00,0x00,0x00,0xC0,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/*"h",72*/
{0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00},/*"i",73*/
{0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x1C,0x04,0x04,0x04,0x04,0x04,0x04,0x44,0x78},/*"j",74*/
{0x00,0x00,0x00,0xC0,0x40,0x40,0x40,0x4E,0x48,0x50,0x68,0x48,0x44,0xEE,0x00,0x00},/*"k",75*/
{0x00,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00},/*"l",76*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x49,0x49,0x49,0x49,0x49,0xED,0x00,0x00},/*"m",77*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xDC,0x62,0x42,0x42,0x42,0x42,0xE7,0x00,0x00},/*"n",78*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/*"o",79*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD8,0x64,0x42,0x42,0x42,0x44,0x78,0x40,0xE0},/*"p",0*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x22,0x42,0x42,0x42,0x22,0x1E,0x02,0x07},/*"q",81*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEE,0x32,0x20,0x20,0x20,0x20,0xF8,0x00,0x00},/*"r",82*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x42,0x40,0x3C,0x02,0x42,0x7C,0x00,0x00},/*"s",83*/
{0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x0C,0x00,0x00},/*"t",84*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC6,0x42,0x42,0x42,0x42,0x46,0x3B,0x00,0x00},/*"u",85*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x28,0x10,0x10,0x00,0x00},/*"v",86*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD7,0x92,0x92,0xAA,0xAA,0x44,0x44,0x00,0x00},/*"w",87*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x24,0x18,0x18,0x18,0x24,0x76,0x00,0x00},/*"x",88*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x28,0x18,0x10,0x10,0xE0},/*"y",89*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x44,0x08,0x10,0x10,0x22,0x7E,0x00,0x00},/*"z",90*/
{0x00,0x03,0x04,0x04,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x04,0x04,0x03,0x00},/*"{",91*/
{0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},/*"|",92*/
{0x00,0x60,0x10,0x10,0x10,0x10,0x10,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x60,0x00},/*"}",93*/
{0x30,0x4C,0x43,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"~",94*/
};





void draw_char (char c,int x,int y,int color)
{
    unsigned char buff[24*2]={0};
    for(int t=0;t<16;t++) buff[t]=g_asc2_1608[c-0x20][t];
    for (int j=0;j<16;j++)
    {
        for (int i=0;i<8;i++)
        {
      if((buff[j]<<i)&0x80)
        draw_point (x+i,y+j,color);
        }
    }
}


void draw_str (char *txt,int x,int y,int color)
{
    if (txt==0) return;
    while (*txt)
    {
        if ((*txt&0x80)==0)
        {
            draw_char(*txt,x,y,color);
            x+=8;
            txt++;
        }
    }
}


void draw_num (int num,int x,int y,int color)
{
  char str[10]={0};
  str[0]='0'+num/10000;
  str[1]='0'+num%10000/1000;
  str[2]='0'+num%1000/100;
  str[3]='0'+num%100/10;
  str[4]='0'+num%10;
  draw_str(str,x,y,color);
}









































typedef struct _boll_def{
    int x;
    int y;
    int r;
    int color;
    int stat;// when stat = 1, delete
    struct _boll_def *next;
    struct _boll_def *prev;
}boll_def;


typedef struct _boll_list{
    int num;
    boll_def *head;
    boll_def *tail;
}boll_list;




typedef struct _gun_def{
    int angle;
    int x;
    int y;
    int r;
    int color;
}gun_def;


typedef struct _line_def{
    double k;
    double b;
}line_def;

typedef struct _boll_heap{
    int num;
    int max;
    boll_def *b[0];
}boll_heap;


typedef struct _map_def
{
    boll_list bolls;
    gun_def gun;
    boll_heap *heap;
    int score;
    int end;
}map_def;


int get_color(int color_num){
  int c=(rand()%color_num);
  if(c<0) c=-c;
  return c+1;
}

boll_heap *boll_heap_creat(int max_num){
    boll_heap *h=malloc(sizeof(boll_heap)+sizeof(boll_def *)*max_num);
    if(h){
        memset(h,0,sizeof(boll_heap)+sizeof(boll_def *)*max_num);
        h->max=max_num;
    }
    return h;
}

void boll_heap_clear(boll_heap *h)
{
    memset(h->b,0,sizeof(boll_def *)*h->num);
    h->num=0;
}


void boll_list_append(boll_list *list,int x,int y,int r,int color);



void boll_list_init(boll_list *list,int r,int num,int color_num)
{
    memset(list,0,sizeof(boll_list));
    int x=r,y=r,color=1;
    for(int i=0;i<num;i++)
    {
        color=get_color(color_num);
        boll_list_append(list,x,y,r,color);
        x+=2*r;
        if(x>240) {
            y+=2*r;
            x=r;
        }
    }
}
void boll_list_append(boll_list *list,int x,int y,int r,int color)
{
    boll_def *b=calloc(1,sizeof(boll_def));
    b->x=x;
    b->y=y;
    b->r=r;
    b->color=color;
    if(list->head==0){
        list->head=b;
        list->tail=b;
    }
    else{
        boll_def *t=list->head;
        list->head=b;
        b->next=t;
        t->prev=list->head;
    }
    list->num++;
}


void boll_list_del(boll_list *list,boll_def *b){
    if(list->num<=0) return;
    if(list->head==b){
        list->head=b->next;
        b->next->prev=0;
    }else if(list->tail==b){
        list->tail=b->prev;
        b->prev->next=0;
        }
        else{
        b->prev->next=b->next;
        b->next->prev=b->prev;
    }
    list->num--;
    free(b);
}

// delete list
void boll_list_del_all(boll_list *list){
    while(list->num>0){
        //printf("num:%d\n", list->num);
        boll_list_del(list,list->head);
    }
}

// calculate distance between shooter and ball
double calc_boll_to_line(boll_def *b,line_def *l,double *x_,double *y_){
    line_def l2={0};
    double x,y;
    if(l->k==0)
    {
//        return abs(b->x);
        return abs(b->y);
    }else{
        l2.k=-1/l->k;
        //printf("l2.k:%lf, l->k:%lf\n", l2.k, l->k);
        l2.b=b->y-l2.k*b->x;
        //printf("l2.b:%lf, b->x:%d, b->y:%d\n", l2.b, b->x, b->y);
        x=-(l->b-l2.b)/(l->k-l2.k);
        //printf("x:%lf, l->b:%lf\n", x, l->b);
        y=l2.k*x+l2.b;
        //printf("y:%lf\n", y);
        if(x_) *x_=x;
        if(y_) *y_=y;
        double result = sqrt((b->x-x)*(b->x-x)+(b->y-y)*(b->y-y));
        //printf("result:%lf\n", result);
        return result;
    }
}



// calculate distance between balls
// If the colors are the same and the distance is close to the two radius
// then they will be implicated
double calc_boll_to_boll(boll_def *b1,boll_def *b2){
    double dx=b1->x-b2->x;
    double dy=b1->y-b2->y;
    return sqrt(dx*dx+dy*dy);
}



// calculate destinationï¼Œ]
// landing point is at the first intersection of the ray and two circles
// with the radius of the stationary ball's center as their radius.
int calc_point(boll_def *b,line_def *l,double *x_,double *y_){
    double x,y,y1,y2;
    double dis=calc_boll_to_line(b,l,&x,&y);
    //printf("dist:%f\n", dis);
    if(dis>b->r*2) return 0;
    double dx=sqrt((b->r*b->r*4-dis*dis)/(1+l->k*l->k));
    //printf("dx:%f\n",dx);
    y1=l->k*(x-dx)+l->b;
    y2=l->k*(x+dx)+l->b;
    if(y1<y2){
    //if (l->k > 0) {
        if(x_) *x_=x+dx;
        if(y_) *y_=y2;
    }else{
        if(x_) *x_=x-dx;
        if(y_) *y_=y1;
    }
    //printf("x:%f, y:%f\n", *x_, *y_);
    return 1;
}


void map_init(map_def *m){
    // initalize balls
    // r = 12, size = 50, 4 colors
    boll_list_init(&m->bolls,12,50,4);
    m->heap=boll_heap_creat(100);
    m->score=0;
    m->gun.x=240/2;
    m->gun.y=240-12;
    m->gun.angle=91;
    m->gun.color=get_color(4);
    m->gun.r=12;
}


// define color
static const unsigned short g_color_table[]={
    0xff00,0xf0ff,0xfff0,0x0fff,0xf00f,0x0f0f
};



void gun_show(gun_def *g)
{
    int x2,y2;
    double angle=g->angle*3.1415926/180.0;
    x2=g->x-g->r*2*cos(angle);
    y2=g->y-g->r*2*sin(angle);
    draw_circle(g->x,g->y,g->r,g_color_table[g->color]);
    draw_line(g->x,g->y,x2,y2,0xffff);
}


void map_show(map_def *m)
{
    boll_def *b=m->bolls.head;
    for(int i=0;i<m->bolls.num;i++){
        draw_circle(b->x,b->y,b->r,g_color_table[b->color]);
        b=b->next;
        if(b==0) break;
    }
    gun_show(&m->gun);
    
    draw_line(241,0,241,240,0xffff);
    draw_line(241,40,320,40,0xffff);
    draw_str("score:",245,2,0xf0f0);
    draw_num(m->score,245+8,2+20,0x0f0f);
}






// add to graph if theres can not find in boll_heap
void boll_heap_append(boll_heap *h,boll_def *b){
  
    for(int i=0;i<h->num;i++)
    {
        if(h->b[i]==b)
          return;
    }
    if(h->num<h->max)
    {
        h->b[h->num]=b;
        h->num++;
    }
}


// look for the adjacent balls and add to boll_heap
void map_find_neighbor(map_def *m,boll_def *b)
{
    double dis;
    boll_def *tb=m->bolls.head;
    while(tb){
        dis=calc_boll_to_boll(tb,b);
        if((dis<b->r*2+5)&&(b->color==tb->color))
        //if(b->color==tb->color)
        //if(dis<b->r*2+5)
        {
            boll_heap_append(m->heap,tb);
        }
        tb=tb->next;
    }
}


void map_send_boll(map_def *m){
    double x=0,y=0;
    double tx,ty;
    double angle=m->gun.angle*3.1415926/180.0;
    //printf("angle:%f, m->angle:%d\n",angle, m->gun.angle);
    line_def line={0};
    line.k=tan(angle);
    //printf("k:%f\n",line.k);
    line.b=m->gun.y-line.k*m->gun.x;
    boll_def *b=m->bolls.head;
    //printf("b:%f\n",line.b);
    while(b){
        if(calc_point(b,&line,&tx,&ty)==1)
        {
            if(ty>y){
                y=ty;x=tx;
            }
        }
        b=b->next;
    }
    //printf("x:%lf, y:%lf\n",x, y);

    if(x==0 && y ==0) {
        if (line.k <= 2 && line.k >= 0.3) {
            x = 12;
            y = x*line.k+line.b;
        } else if (line.k >= -2 && line.k <= -0.3) {
            x = 228;
            y = x*line.k+line.b;
        } else if (line.k > 2 || line.k < -2) {
            y = 12;
            x = (y-line.b)/line.k;
        } else {
            y = 240;
        }
    } else if (x<12){
        x = 12;
        y = x*line.k+line.b;
    } else if (x>228){
        x = 228;
        y = x*line.k+line.b;
    } else if (y<12) {
        y = 12;
        x = (y-line.b)/line.k;
    }

    if(y>240-24-12)
    {
      // out of boundary
      m->end=2;
      return;
    }
    
    // find all balls with same color that are close to the one
    boll_list_append(&m->bolls,x,y,12,m->gun.color);
    b=m->bolls.head;
    boll_heap_clear(m->heap);
    boll_heap_append(m->heap,b);
    for(int i=0;i<m->heap->num;i++)
    {
        map_find_neighbor(m,m->heap->b[i]);
    }
    
    if(m->heap->num>=3)
    {
      for(int i=0;i<m->heap->num;i++)
      {
          boll_list_del(&m->bolls,m->heap->b[i]);
      }
      m->score+=m->heap->num;
    }
    
    if(m->bolls.num==0)
    {
      // game over
      m->end=1;
      return ;
    }
    
    m->gun.color=get_color(4);
    explosion_sound();
}





volatile int pixel_buffer_start;
int main() {
    srand((unsigned)time(NULL));

    volatile int * pixel_ctrl_ptr = (int *)0xFF203020;
    *(pixel_ctrl_ptr + 1) = 0xC8000000;
    wait_for_vsync();
    pixel_buffer_start = *pixel_ctrl_ptr;
    clear_screen(); // pixel_buffer_start points to the pixel buffer
    /* set back pixel buffer to start of SDRAM memory */
    *(pixel_ctrl_ptr + 1) = 0xC0000000;
    pixel_buffer_start = *(pixel_ctrl_ptr + 1); // we draw on the back buffer
    clear_screen(); // pixel_buffer_start points to the pixel buffer
    
    //int KEY_value;
    map_def map={0};
    map_init(&map);
    draw_fill(0,0,320,240,0);
    map_show(&map);
    while(1){
    sleep(0.2);
        //KEY_value = *(KEY_ptr + 3);
        if(KEY_NUM>0){
            if(KEY_value==0x01){
                if(map.gun.angle<175)
                    map.gun.angle+=5;
            }
            else if(KEY_value==0x02){
                if(map.gun.angle>5)
                    map.gun.angle-=5;
            }
            else if(KEY_value==0x04)
            {
              if(map.end==0)
                map_send_boll(&map);
            } else if (KEY_value==0x08){
              clear_screen();
              boll_list_del_all(&map.bolls);
              map_init(&map);
              draw_fill(0,0,320,240,0);
              map_show(&map);
            }
            draw_fill(0,0,320,240,0);
            if(map.end==0) {
              map_show(&map);
            } else if (map.end==1) {
              draw_fill(50,120-25,320-100,50,0x0fff);
              draw_str("YOU WON!",320/2-9*8/2,240/2-8,0xf0ff);
              map.end = 0;
              sleep(2);
              clear_screen();
              draw_fill(50,120-25,320-100,50,0x0fff);
              draw_str("NEXT LEVEL",320/2-9*8/2,240/2-8,0xf0ff);
              sleep(2);
              clear_screen();
              boll_list_del_all(&map.bolls);
              map_init(&map);
              draw_fill(0,0,320,240,0);
              map_show(&map);
            }
            else{
              draw_fill(50,120-25,320-100,50,0x0fff);
              draw_str("GAME OVER",320/2-9*8/2,240/2-8,0xf0ff);
              map.end = 0;
              sleep(2);
              clear_screen();
              draw_fill(50,120-25,320-100,50,0x0fff);
              draw_str("TRY AGAIN",320/2-9*8/2,240/2-8,0xf0ff);
              sleep(2);
              clear_screen();
              boll_list_del_all(&map.bolls);
              map_init(&map);
              draw_fill(0,0,320,240,0);
              map_show(&map);
            }
        }
//        wait_for_vsync(); // swap front and back buffers on VGA vertical sync
//        pixel_buffer_start = *(pixel_ctrl_ptr + 1); // new back buffer
    }
    return 0;
}






